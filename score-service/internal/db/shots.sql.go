// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shots.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const batchCreateShots = `-- name: BatchCreateShots :many
INSERT INTO shots (
    x,
    y,
    score,
    distance_from_center,
    is_ten,
    is_x,
    is_miss,
    set_id
) SELECT
      unnest($1::DECIMAL[]),
      unnest($2::DECIMAL[]),
      unnest($3::INTEGER[]),
      unnest($4::DECIMAL[]),
      unnest($5::BOOLEAN[]),
      unnest($6::BOOLEAN[]),
      unnest($7::BOOLEAN[]),
      $8
          RETURNING id, x, y, score, distance_from_center, is_ten, is_x, is_miss, notes, set_id, created_at, updated_at, deleted_at
`

type BatchCreateShotsParams struct {
	Column1 []pgtype.Numeric `json:"column_1"`
	Column2 []pgtype.Numeric `json:"column_2"`
	Column3 []int32          `json:"column_3"`
	Column4 []pgtype.Numeric `json:"column_4"`
	Column5 []bool           `json:"column_5"`
	Column6 []bool           `json:"column_6"`
	Column7 []bool           `json:"column_7"`
	SetID   uuid.UUID        `json:"set_id"`
}

func (q *Queries) BatchCreateShots(ctx context.Context, arg BatchCreateShotsParams) ([]Shot, error) {
	rows, err := q.db.Query(ctx, batchCreateShots,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.SetID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shot{}
	for rows.Next() {
		var i Shot
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.Score,
			&i.DistanceFromCenter,
			&i.IsTen,
			&i.IsX,
			&i.IsMiss,
			&i.Notes,
			&i.SetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createShot = `-- name: CreateShot :one
WITH target_info AS (
    SELECT zones_config, max_score, has_x
    FROM target_faces tf
             JOIN qualification_rounds qr ON tf.id = qr.target_face_id
             JOIN sets s ON qr.id = s.parent_round_id
    WHERE s.id = $4 AND tf.deleted_at IS NULL AND qr.deleted_at IS NULL AND s.deleted_at IS NULL
    LIMIT 1
    )
INSERT INTO shots (
    x,
    y,
    score,
    distance_from_center,
    is_ten,
    is_x,
    is_miss,
    notes,
    set_id
) VALUES (
    $1,
    $2,
    $3,
    SQRT(POWER($1, 2) + POWER($2, 2)),
    (SELECT calculate_shot_score($1, $2, (SELECT target_face_id FROM qualification_rounds qr JOIN sets s ON qr.id = s.parent_round_id WHERE s.id = $4 LIMIT 1))) = 10,
    (SELECT calculate_shot_score($1, $2, (SELECT target_face_id FROM qualification_rounds qr JOIN sets s ON qr.id = s.parent_round_id WHERE s.id = $4 LIMIT 1))) = 10
    AND SQRT(POWER($1, 2) + POWER($2, 2)) < 30.5,
    (SELECT calculate_shot_score($1, $2, (SELECT target_face_id FROM qualification_rounds qr JOIN sets s ON qr.id = s.parent_round_id WHERE s.id = $4 LIMIT 1))) = 0,
    $4,
    $5
)
    RETURNING id, x, y, score, distance_from_center, is_ten, is_x, is_miss, notes, set_id, created_at, updated_at, deleted_at
`

type CreateShotParams struct {
	X     pgtype.Numeric `json:"x"`
	Y     pgtype.Numeric `json:"y"`
	Score int32          `json:"score"`
	Notes pgtype.Text    `json:"notes"`
	SetID uuid.UUID      `json:"set_id"`
}

func (q *Queries) CreateShot(ctx context.Context, arg CreateShotParams) (Shot, error) {
	row := q.db.QueryRow(ctx, createShot,
		arg.X,
		arg.Y,
		arg.Score,
		arg.Notes,
		arg.SetID,
	)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.X,
		&i.Y,
		&i.Score,
		&i.DistanceFromCenter,
		&i.IsTen,
		&i.IsX,
		&i.IsMiss,
		&i.Notes,
		&i.SetID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getShot = `-- name: GetShot :one
SELECT id, x, y, score, distance_from_center, is_ten, is_x, is_miss, notes, set_id, created_at, updated_at, deleted_at FROM shots
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetShot(ctx context.Context, id uuid.UUID) (Shot, error) {
	row := q.db.QueryRow(ctx, getShot, id)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.X,
		&i.Y,
		&i.Score,
		&i.DistanceFromCenter,
		&i.IsTen,
		&i.IsX,
		&i.IsMiss,
		&i.Notes,
		&i.SetID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getShotsBySet = `-- name: GetShotsBySet :many
SELECT id, x, y, score, distance_from_center, is_ten, is_x, is_miss, notes, set_id, created_at, updated_at, deleted_at FROM shots
WHERE set_id = $1 AND deleted_at IS NULL
ORDER BY created_at
`

func (q *Queries) GetShotsBySet(ctx context.Context, setID uuid.UUID) ([]Shot, error) {
	rows, err := q.db.Query(ctx, getShotsBySet, setID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shot{}
	for rows.Next() {
		var i Shot
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.Score,
			&i.DistanceFromCenter,
			&i.IsTen,
			&i.IsX,
			&i.IsMiss,
			&i.Notes,
			&i.SetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
