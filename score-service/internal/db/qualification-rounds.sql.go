// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: qualification-rounds.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createQualificationRound = `-- name: CreateQualificationRound :one
INSERT INTO qualification_rounds (
    external_user_id,
    round_type,
    name,
    distance,
    total_sets,
    shots_per_set,
    target_face_id,
    notes,
    start_time
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    RETURNING id, external_user_id, round_type, name, distance, total_sets, shots_per_set, total_score, average_score, completed_sets, start_time, end_time, notes, target_face_id, competition_id, created_at, updated_at, deleted_at
`

type CreateQualificationRoundParams struct {
	ExternalUserID string             `json:"external_user_id"`
	RoundType      string             `json:"round_type"`
	Name           string             `json:"name"`
	Distance       int32              `json:"distance"`
	TotalSets      int32              `json:"total_sets"`
	ShotsPerSet    int32              `json:"shots_per_set"`
	TargetFaceID   uuid.UUID          `json:"target_face_id"`
	Notes          pgtype.Text        `json:"notes"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

func (q *Queries) CreateQualificationRound(ctx context.Context, arg CreateQualificationRoundParams) (QualificationRound, error) {
	row := q.db.QueryRow(ctx, createQualificationRound,
		arg.ExternalUserID,
		arg.RoundType,
		arg.Name,
		arg.Distance,
		arg.TotalSets,
		arg.ShotsPerSet,
		arg.TargetFaceID,
		arg.Notes,
		arg.StartTime,
	)
	var i QualificationRound
	err := row.Scan(
		&i.ID,
		&i.ExternalUserID,
		&i.RoundType,
		&i.Name,
		&i.Distance,
		&i.TotalSets,
		&i.ShotsPerSet,
		&i.TotalScore,
		&i.AverageScore,
		&i.CompletedSets,
		&i.StartTime,
		&i.EndTime,
		&i.Notes,
		&i.TargetFaceID,
		&i.CompetitionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getQualificationRound = `-- name: GetQualificationRound :one
SELECT id, external_user_id, round_type, name, distance, total_sets, shots_per_set, total_score, average_score, completed_sets, start_time, end_time, notes, target_face_id, competition_id, created_at, updated_at, deleted_at FROM qualification_rounds WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetQualificationRound(ctx context.Context, id uuid.UUID) (QualificationRound, error) {
	row := q.db.QueryRow(ctx, getQualificationRound, id)
	var i QualificationRound
	err := row.Scan(
		&i.ID,
		&i.ExternalUserID,
		&i.RoundType,
		&i.Name,
		&i.Distance,
		&i.TotalSets,
		&i.ShotsPerSet,
		&i.TotalScore,
		&i.AverageScore,
		&i.CompletedSets,
		&i.StartTime,
		&i.EndTime,
		&i.Notes,
		&i.TargetFaceID,
		&i.CompetitionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getQualificationRoundsForUser = `-- name: GetQualificationRoundsForUser :many
SELECT id, external_user_id, round_type, name, distance, total_sets, shots_per_set, total_score, average_score, completed_sets, start_time, end_time, notes, target_face_id, competition_id, created_at, updated_at, deleted_at FROM qualification_rounds WHERE external_user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetQualificationRoundsForUser(ctx context.Context, externalUserID string) ([]QualificationRound, error) {
	rows, err := q.db.Query(ctx, getQualificationRoundsForUser, externalUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualificationRound{}
	for rows.Next() {
		var i QualificationRound
		if err := rows.Scan(
			&i.ID,
			&i.ExternalUserID,
			&i.RoundType,
			&i.Name,
			&i.Distance,
			&i.TotalSets,
			&i.ShotsPerSet,
			&i.TotalScore,
			&i.AverageScore,
			&i.CompletedSets,
			&i.StartTime,
			&i.EndTime,
			&i.Notes,
			&i.TargetFaceID,
			&i.CompetitionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
